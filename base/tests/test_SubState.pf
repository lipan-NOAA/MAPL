#define I_AM_PFUNIT
#include "MAPL_ErrLog.h"

module test_subState
   use ESMF
   use pfunit
   use ESMF_TestMethod_mod
   use ESMF_TestCase_mod
   use ESMF_TestParameter_mod
   use MAPL_CubedSphereGridFactoryMod, only: CubedSphereGridFactory
   use MAPL_OpenMP_Support
   use MAPL_MaplGrid

   implicit none

   @testParameter
   type, extends(ESMF_TestParameter) :: StateSpec
      character(:), allocatable :: state_name
      integer :: num_subgrids
   contains
      procedure :: toString
   end type StateSpec

   @testCase(constructor=SubStateTest, testParameters={make_parameters()})
   type, extends(ESMF_TestCase) :: SubStateTest
      character(:), allocatable :: state_name
      integer :: num_subgrids
      type(ESMF_State) :: state
   contains
      procedure :: setup
      procedure :: teardown
   end type SubStateTest

   interface SubStateTest
      module procedure new_SubStateTest
   end interface SubStateTest

   interface StateSpec
      module procedure new_StateSpec
   end interface StateSpec

contains

   function make_parameters() result(params)
      type(StateSpec), allocatable :: params(:)

      params = [ &
           StateSpec(name='empty',      num_subgrids=1), &
           StateSpec(name='empty',      num_subgrids=2), &
           StateSpec(name='one_field',  num_subgrids=1), &
           StateSpec(name='one_field',  num_subgrids=2), &
           StateSpec(name='one_bundle', num_subgrids=1), &
           StateSpec(name='one_bundle', num_subgrids=2), &
           StateSpec(name='one_state',  num_subgrids=1), &
           StateSpec(name='one_state',  num_subgrids=2),  &
           StateSpec(name='nested',     num_subgrids=1), &
           StateSpec(name='nested',     num_subgrids=3)  &
           ]
   end function make_parameters
   
   function new_SubStateTest(test_parameter) result(a_test)
      type(SubStateTest) :: a_test
      class(StateSpec), intent(in) :: test_parameter

      ! unpack params
      associate( p => test_parameter)
        a_test%state_name = p%state_name
        a_test%num_subgrids = p%num_subgrids
      end associate

   end function new_SubStateTest

   function new_StateSpec(name, num_subgrids) result(spec)
      type(StateSpec) :: spec

      character(*), intent(in) :: name
      integer, intent(in) :: num_subgrids

      spec%state_name = name
      spec%num_subgrids = num_subgrids

      call spec%setNumPETsRequested(6)

   end function new_StateSpec


   subroutine setup(this)
      class(SubStateTest), intent(inout) :: this
      integer :: status
      type(CubedSphereGridFactory) :: cs_factory
      type(ESMF_Grid) :: grid

      type(ESMF_Field) :: field_1, field_2, field_3
      type(ESMF_FieldBundle) :: bundle_1, bundle_2
      type(ESMF_State) :: state_1, state_2
      

      cs_factory = CubedSphereGridFactory(im_world=7,nx=1,ny=1,lm=1,_RC)
      grid = cs_factory%make_grid(_RC)

      this%state = ESMF_StateCreate(name=this%state_name)

      select case (this%state_name)
      case ('one_field', 'nested')
         field_1 = ESMF_FieldCreate(grid, name='field_1', typekind=ESMF_TYPEKIND_I4, _RC)
         call ESMF_StateAdd(this%state, [field_1], _RC)
      end select

      select case (this%state_name)
      case ('one_bundle', 'nested')
         bundle_1 = ESMF_FieldBundleCreate(name='bundle_1', _RC)
         call ESMF_StateAdd(this%state, [bundle_1], _RC)
      end select

      select case(this%state_name)
      case ('one_state', 'nested')
         state_1 = ESMF_StateCreate(name='state_1', _RC)
         call ESMF_StateAdd(this%state, [state_1], _RC)
      end select

      if (this%state_name == 'nested') then
         ! add field to inner bundle 'bundle_1'
         field_2 = ESMF_FieldCreate(grid, name='field_2', typekind=ESMF_TYPEKIND_I4, _RC)
         call ESMF_FieldBundleAdd(bundle_1, [field_2], _RC)
         ! I think when the substates are not updating bundle_1 to contain field_2
         ! when the call above is commented out, the item count is the same

         ! add field to inner state 'state_1'
         field_3 = ESMF_FieldCreate(grid, name='field_3', typekind=ESMF_TYPEKIND_I4, _RC)
         call ESMF_StateAdd(state_1, [field_3], _RC)

         ! add bundle to inner state 'state_1'
         bundle_2 = ESMF_FieldBundleCreate(name='bundle_2', _RC)
         call ESMF_StateAdd(state_1, [bundle_2], _RC)

         ! add state to inner state 'state_1'
         state_2 = ESMF_StateCreate(name='state_2', _RC)
         call ESMF_StateAdd(state_1, [state_2], _RC)
      end if
         
      
   end subroutine setup

   subroutine teardown(this)
      class(SubStateTest), intent(inout) :: this
   end subroutine teardown

   @test
   subroutine test_name(this)
      class(SubStateTest), intent(inout) :: this

      type(ESMF_State), allocatable :: substates(:)
      character(ESMF_MAXSTR) :: name
      integer :: i, status

      substates = make_SubStates(this%state, num_subgrids=this%num_subgrids, _RC)

      do i = 1, this%num_subgrids
         call ESMF_StateGet(substates(i), name=name, _RC)
         @assertEqual(this%state_name, trim(name))
      end do

   end subroutine test_name
      

   @test
   subroutine test_num_items(this)
      class(SubStateTest), intent(inout) :: this

      type(ESMF_State), allocatable :: substates(:)
      integer :: i, status
      integer:: item_count

      substates = make_SubStates(this%state, num_subgrids=this%num_subgrids, _RC)

      do i = 1, this%num_subgrids
         call ESMF_StateGet(substates(i), itemcount=item_count, _RC)
         
         select case (this%state_name)
         case ('empty')
            @assert_that(item_count, is(0))
         case ('one_field','one_bundle','one_state')
            @assert_that(item_count, is(1))
         case ('nested')
            @assert_that(item_count, is(3))
         end select
      end do

   end subroutine test_num_items
      
   @test
   subroutine test_num_items_nested(this)
      class(SubStateTest), intent(inout) :: this

      type(ESMF_State), allocatable :: substates(:)
      integer :: i, status
      integer:: item_count

      substates = make_SubStates(this%state, num_subgrids=this%num_subgrids, _RC)

      do i = 1, this%num_subgrids
         call ESMF_StateGet(substates(i), itemcount=item_count, nestedFlag=.true., _RC)
         select case (this%state_name)
         case ('empty')
            @assert_that(item_count, is(0))
         case ('one_field','one_bundle','one_state')
            @assert_that(item_count, is(1))
         case ('nested')
            ! field_1, field_2, field_3, bundle_1, bundle_2, state_1, state_2
            @assert_that(item_count, is(7))
         end select
      end do

   end subroutine test_num_items_nested

   ! Check that each substate has the right elements.
   @test
   subroutine test_subfield(this)
      class(SubStateTest), intent(inout) :: this

      type(ESMF_State), allocatable :: substates(:)
      integer :: status
      integer :: i
      type(ESMF_StateItem_Flag) :: item_type

      substates = make_SubStates(this%state, num_subgrids=this%num_subgrids, _RC)

      do i = 1, this%num_subgrids
         if (this%state_name == 'one_field' .or. this%state_name == 'nested') then
            call ESMF_StateGet(substates(i), itemname='field_1', itemtype=item_type, _RC)
            @assertTrue(item_type == ESMF_STATEITEM_FIELD)
         end if
         if (this%state_name == 'one_bundle' .or. this%state_name == 'nested') then
            call ESMF_StateGet(substates(i), itemname='bundle_1', itemtype=item_type, _RC)
            @assertTrue(item_type == ESMF_STATEITEM_FIELDBUNDLE)
         end if
         if (this%state_name == 'one_state' .or. this%state_name == 'nested') then
            call ESMF_StateGet(substates(i), itemname='state_1', itemtype=item_type, _RC)
            @assertTrue(item_type == ESMF_STATEITEM_STATE)
         end if
         if (this%state_name == 'nested') then
            call ESMF_StateGet(substates(i), itemname='state_1/field_3', itemtype=item_type,_RC)
            @assertTrue(item_type == ESMF_STATEITEM_FIELD)
            call ESMF_StateGet(substates(i), itemname='state_1/bundle_2', itemtype=item_type, _RC)
            @assertTrue(item_type == ESMF_STATEITEM_FIELDBUNDLE)
            call ESMF_StateGet(substates(i), itemname='state_1/state_2', itemtype=item_type, _RC)
            @assertTrue(item_type == ESMF_STATEITEM_STATE)
            call ESMF_StateGet(substates(i), itemname='bundle_1/field_2', itemtype=item_type, _RC)
            @assertTrue(item_type == ESMF_STATEITEM_FIELD)

         end if
      end do
   end subroutine test_subfield
      
   function toString(this) result(string)
      character(len=:), allocatable :: string
      class (StateSpec), intent(in) :: this
      character(len=2) :: buf

      string = '{name:'//this%state_name
      write(buf,'(i2.0)') this%num_subgrids
      string = string // ',n_grids:'//buf
      string = string // '}'

   end function toString


end module test_subState
