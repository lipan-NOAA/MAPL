#define I_AM_PFUNIT
#include "MAPL_ErrLog.h"
module test_SubField
   use ESMF
   use pfunit
   use ESMF_TestMethod_mod
   use ESMF_TestCase_mod
   use ESMF_TestParameter_mod
   use MAPL_CubedSphereGridFactoryMod, only: CubedSphereGridFactory
   use MAPL_OpenMP_Support
   use MAPL_MaplGrid

   implicit none


   ! Tests
   ! - num subfields
   ! - name
   ! - attributes
   ! - grid (== expected grid or "match" expected grid?)
   ! - typekind
   ! - rank
   ! - staggering
   ! - data (== slice of actual field)
   ! - aliased (change value in field, changed in subfield)

   

   integer, parameter :: IM = 10
   integer, parameter :: NX = 1
   integer, parameter :: LM = 5

   @testParameter
   type, extends(ESMF_TestParameter) :: FieldSpec
      character(:), allocatable :: field_name
      integer :: im
      character(:), allocatable :: tk_str
      integer :: rank
      integer :: num_subgrids
      integer :: nx, ny
      character(:), allocatable :: atts
   contains
      procedure :: toString
   end type FieldSpec

   @testCase(constructor=SubFieldTest, testParameters={make_parameters()})
   type, extends(ESMF_TestCase) :: SubFieldTest
      character(:), allocatable :: field_name
      integer :: im
      type(ESMF_TYPEKIND_FLAG) :: typekind
      character(:), allocatable :: tk_str
      integer :: rank
      integer :: num_subgrids
      integer :: nx, ny
      type(Interval), allocatable :: bounds(:)
      type(ESMF_Grid), allocatable :: subgrids(:)
      type(ESMF_Field) :: field
      type(ESMF_Grid) :: grid
      character(:), allocatable :: atts
   contains
      procedure :: setup
      procedure :: teardown
   end type SubFieldTest

   interface SubFieldTest
      module procedure new_SubFieldTest
   end interface SubFieldTest

   interface FieldSpec
      module procedure new_FieldSpec
   end interface FieldSpec

contains


   function make_parameters() result(params)
      type(FieldSpec), allocatable :: params(:)

      params = [ &
           FieldSpec(field_name='A', im=5, tk_str='R4', rank=2, num_subgrids=1, nxy=[1,1]), &
           FieldSpec(field_name='B', im=5, tk_str='R8', rank=2, num_subgrids=2, nxy=[1,1], atts='A'), &
           FieldSpec(field_name='C', im=7, tk_str='I4', rank=3, num_subgrids=3, nxy=[1,1], atts='B'), &
           FieldSpec(field_name='D', im=7, tk_str='I8', rank=3, num_subgrids=3, nxy=[1,1], atts='C') &
           FieldSpec(field_name='E', im=7, tk_str='I4', rank=4, num_subgrids=2, nxy=[1,1]), &
           FieldSpec(field_name='F', im=7, tk_str='R4', rank=4, num_subgrids=3, nxy=[1,1]), &
           ]

   end function make_parameters
   

   function new_FieldSpec(field_name, im, tk_str, rank, num_subgrids, nxy, atts) result(specs)
      type(FieldSpec) :: specs
      character(*), intent(in) :: field_name
      integer, intent(in) :: im
      character(*), intent(in) :: tk_str
      integer, intent(in) :: rank
      integer, intent(in) :: num_subgrids
      integer, intent(in) :: nxy(2)
      character(*), optional, intent(in) :: atts

      specs%field_name = field_name
      specs%im = im
      specs%tk_str = tk_str
      specs%rank = rank
      specs%num_subgrids = num_subgrids
      specs%nx = nxy(1)
      specs%ny = nxy(2)
      if (present(atts)) then
         specs%atts = atts
      else
         specs%atts = 'none'
      end if
      
      call specs%setNumPETsRequested(product(nxy)*6)

   end function new_FieldSpec

   function new_SubFieldTest(test_parameter) result(a_test)
      type(SubFieldTest) :: a_test
      class(FieldSpec), intent(in) :: test_parameter

      associate(p => test_parameter)
        a_test%field_name = p%field_name
        a_test%im = p%im
        a_test%tk_str = p%tk_str
        a_test%rank = p%rank
        a_test%num_subgrids = p%num_subgrids
        a_test%nx = p%nx
        a_test%ny = p%ny
        
        select case (p%tk_str)
        case ('R4')
           a_test%typekind = ESMF_TYPEKIND_R4
        case ('R8')
           a_test%typekind = ESMF_TYPEKIND_R8
        case ('I4')
           a_test%typekind = ESMF_TYPEKIND_I4
        case ('I8')
           a_test%typekind = ESMF_TYPEKIND_I8
        end select
        
        a_test%atts = p%atts
        
      end associate

   end function new_SubFieldTest

   subroutine setup(this)
      class(SubFieldTest), intent(inout) :: this
      type(CubedSphereGridFactory) :: cs_factory

      integer :: status, i, j, k
      integer :: local_count(3)
      real(kind=ESMF_KIND_R8), pointer :: lats(:,:), lons(:,:)

      real(kind=ESMF_KIND_R4), pointer :: ptr_2d_r4(:,:)
      real(kind=ESMF_KIND_R8), pointer :: ptr_2d_r8(:,:)
      integer(kind=ESMF_KIND_I4), pointer :: ptr_2d_i4(:,:)
      integer(kind=ESMF_KIND_I8), pointer :: ptr_2d_i8(:,:)

      real(kind=ESMF_KIND_R4), pointer :: ptr_3d_r4(:,:,:)
      real(kind=ESMF_KIND_R8), pointer :: ptr_3d_r8(:,:,:)
      integer(kind=ESMF_KIND_I4), pointer :: ptr_3d_i4(:,:,:)
      integer(kind=ESMF_KIND_I8), pointer :: ptr_3d_i8(:,:,:)

      real(kind=ESMF_KIND_R4), pointer :: ptr_4d_r4(:,:,:,:)
      real(kind=ESMF_KIND_R8), pointer :: ptr_4d_r8(:,:,:,:)
      integer(kind=ESMF_KIND_I4), pointer :: ptr_4d_i4(:,:,:,:)
      integer(kind=ESMF_KIND_I8), pointer :: ptr_4d_i8(:,:,:,:)

      integer, allocatable :: data(:,:,:)
      integer, allocatable :: data_4d(:,:,:,:)

      call build_grid_subgrids()

      call MAPL_GridGet(this%grid,localcellcountPerDim=local_count, _RC)
      this%bounds = find_bounds(local_count(2), this%num_subgrids)

      select case (this%rank)
      case (2)
         this%field = ESMF_FieldCreate(grid=this%grid, typekind=this%typekind, &
              name=this%field_name, &
              indexflag=ESMF_INDEX_DELOCAL, &
              staggerloc=ESMF_STAGGERLOC_CENTER, _RC)
         
      case (3)
         this%field = ESMF_FieldCreate(grid=this%grid, typekind=this%typekind, &
              name=this%field_name, &
              indexflag=ESMF_INDEX_DELOCAL, &
              ungriddedLBound=[1], ungriddedUBound=[LM], &
              staggerloc=ESMF_STAGGERLOC_CENTER, _RC)

      case (4)
         this%field = ESMF_FieldCreate(grid=this%grid, typekind=this%typekind, &
              name=this%field_name, &
              indexflag=ESMF_INDEX_DELOCAL, &
              ungriddedLBound=[1], ungriddedUBound=[LM], &
              staggerloc=ESMF_STAGGERLOC_CENTER, _RC)
         
      end select

      call add_attributes()
      allocate(data(local_count(1), local_count(2), LM))
      do j = 1, local_count(2)
         do i = 1, local_count(1)
            data(i,j,:) = f(i,j)
         end do
      end do

      allocate(data(local_count(1), local_count(2), local_count(3), LM))
      do k = 1, local_count(3)
         do j = 1, local_count(2)
            do i = 1, local_count(1)
               data(i,j,k,:) = f(i,j)
            end do
         end do
      end do

      select case(this%tk_str)
      case ('R4')
         if (this%rank == 2) then
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_r4, _RC)
            ptr_2d_r4 = data(:,:,1)
         else if (this%rank == 3) ! rank 3
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_r4, _RC)
            
            ptr_3d_r4 = data
         else
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_4d_r4, _RC)
            
         end if
      case ('R8')
         if (this%rank == 2) then 
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_r8, _RC)
            ptr_2d_r8 = data(:,:,1)
         else ! rank 3
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_r8, _RC)
            ptr_3d_r8 = data
         end if
      case ('I4')
         if (this%rank == 2) then 
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_i4, _RC)
            ptr_2d_i4 = data(:,:,1)
         else ! rank 3
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_i4, _RC)
            ptr_3d_i4 = data
         end if
      case ('I8')
         if (this%rank == 2) then 
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_i8, _RC)
            ptr_2d_i8 = data(:,:,1)
         else ! rank 3
            call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_i8, _RC)
            ptr_3d_i8 = data
         end if
      end select

   contains

      subroutine build_grid_subgrids()

         cs_factory = CubedSphereGridFactory(im_world=this%im, nx=this%nx, ny=this%ny, lm=1, _RC)
         
         this%grid = cs_factory%make_grid(_RC)
         
         call ESMF_GridGetCoord(this%grid, coordDim=1, localDE=0, &
              staggerloc=ESMF_STAGGERLOC_CENTER, farrayPtr=lons, _RC)
         
         call ESMF_GridGetCoord(this%grid, coordDim=2, localDE=0, &
              staggerloc=ESMF_STAGGERLOC_CENTER, farrayPtr=lats, _RC)
         
         call MAPL_GridGet(this%grid,localcellcountPerDim=local_count, _RC)
         
         ! Set the coordinates to synthetic values that are easier to 
         ! test
         do j = 1, local_count(2) 
            do i = 1, local_count(1)
               lons(i,j) = j
               lats(i,j) = i
            end do
         end do

         this%subgrids = make_subgrids(this%grid, this%num_subgrids, _RC)
         
      end subroutine build_grid_subgrids

      subroutine add_attributes()
         select case (this%atts)
         case ('A')
            call ESMF_AttributeSet(this%field, name='A', value=1)
         case ('B')
            call ESMF_AttributeSet(this%field, name='B1', value=int(2, kind=ESMF_KIND_I4))
            call ESMF_AttributeSet(this%field, name='B2', value=real(3.,kind=ESMF_KIND_R4))
         case ('C')
            call ESMF_AttributeSet(this%field, name='C1', value=real(3., kind=ESMF_KIND_R8))
            call ESMF_AttributeSet(this%field, name='C2', value=int(2,kind=ESMF_KIND_I4))
            call ESMF_AttributeSet(this%field, name='C3', value=.true.)
         end select
      end subroutine add_attributes


   end subroutine setup

   elemental real function f(i,j)
      integer, intent(in) :: i
      integer, intent(in) :: j
      f = i + 2 * j
   end function f


   subroutine teardown(this)
      class(SubFieldTest), intent(inout) :: this
      integer :: status
      call ESMF_FieldDestroy(this%field, _RC)
      
   end subroutine teardown

   @test
   subroutine test_num_subfields(this)
      class(SubFieldTest), intent(inout) :: this
      integer :: status
      type(ESMF_Field), allocatable :: subfields(:)
      subfields = make_subfields(this%field, this%num_subgrids, _RC)

      @assert_that(this%num_subgrids, is(equal_to(size(subfields))))
      
   end subroutine test_num_subfields

   @test
   subroutine test_subField_name(this)
      class(SubFieldTest), intent(inout) :: this
      integer :: status
      type(ESMF_Field), allocatable :: subfields(:)
      integer :: i
      character(len=ESMF_MAXSTR) :: expected_name, found_name
      
      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      call ESMF_FieldGet(this%field, name=expected_name, _RC)
      
      do i = 1, this%num_subgrids
         call ESMF_FieldGet(subfields(i), name=found_name, _RC)
         @assertEqual(expected_name, found_name)
      end do

   end subroutine test_subField_name

   @test
   subroutine test_subField_attribute_count(this)
      class(SubFieldTest), intent(inout) :: this
      integer :: status
      type(ESMF_Field), allocatable :: subfields(:)
      integer :: i
      integer :: count
      
      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      
      do i = 1, size(subfields)
         call ESMF_AttributeGet(subfields(i), count=count, _RC)
         
         select case (this%atts)
         case ('none')
            @assert_that(count, is(0))
         case ('A')
            @assert_that(count, is(1))
         case ('B')
            @assert_that(count, is(2))
         case('C')
            @assert_that(count,is(3))
         case default
            ! should not reach here
            @assert_that(1, is(0))
         end select
      end do

   end subroutine test_subField_attribute_count
         

   @test
   subroutine test_subField_attribute_typekind(this)
      class(SubFieldTest), intent(inout) :: this
      integer :: status
      type(ESMF_Field), allocatable :: subfields(:)
      integer :: i
      type(ESMF_TYPEKIND_FLAG) :: typekind
      
      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      
      do i = 1, size(subfields)

         select case (this%atts)
         case ('none')
         case ('A')
            call ESMF_AttributeGet(subfields(i), name='A', typekind=typekind, _RC)
             @assertTrue(typekind == ESMF_TYPEKIND_I4)

         case ('B')
            call ESMF_AttributeGet(subfields(i), name='B1', typekind=typekind, _RC)
             @assertTrue(typekind == ESMF_TYPEKIND_I4)

            call ESMF_AttributeGet(subfields(i), name='B2', typekind=typekind, _RC)
            @assertTrue(typekind == ESMF_TYPEKIND_R4)

         case ('C')
            call ESMF_AttributeGet(subfields(i), name='C1', typekind=typekind, _RC)
            @assertTrue(typekind == ESMF_TYPEKIND_R8)

            call ESMF_AttributeGet(subfields(i), name='C2', typekind=typekind, _RC)
            @assertTrue(typekind == ESMF_TYPEKIND_I4)

            call ESMF_AttributeGet(subfields(i), name='C3', typekind=typekind, _RC)
            @assertTrue(typekind == ESMF_TYPEKIND_LOGICAL)

         case default
            ! should not reach here
            @assert_that(1, is(0))
         end select
      end do

   end subroutine test_subField_attribute_typekind
         

   @test
   subroutine test_subField_attribute_values(this)
      class(SubFieldTest), intent(inout) :: this
      integer :: status
      type(ESMF_Field), allocatable :: subfields(:)
      integer :: i

      integer(kind=ESMF_KIND_I4) :: i_value
      real(kind=ESMF_KIND_R4) :: x_value
      real(kind=ESMF_KIND_R8) :: y_value
      logical :: flag
      
      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      
      do i = 1, size(subfields)

         select case (this%atts)
         case ('none')
         case ('A')
            call ESMF_AttributeGet(subfields(i), name='A', value=i_value, _RC)
            @assert_that(i_value, is(1))

         case ('B')
            call ESMF_AttributeGet(subfields(i), name='B1', value=i_value, _RC)
             @assert_that(i_value, is(2))

            call ESMF_AttributeGet(subfields(i), name='B2', value=x_value, _RC)
             @assert_that(x_value, is(3._ESMF_KIND_R4))

         case ('C')
            call ESMF_AttributeGet(subfields(i), name='C1', value=y_value, _RC)
             @assert_that(y_value, is(3._ESMF_KIND_R8))

            call ESMF_AttributeGet(subfields(i), name='C2', value=i_value, _RC)
             @assert_that(i_value, is(2))

            call ESMF_AttributeGet(subfields(i), name='C3', value=flag, _RC)
             @assert_that(flag, is(true()))

         case default
            ! should not reach here
            @assert_that(1, is(0))
         end select
      end do

   end subroutine test_subField_attribute_values
         
   ! This test verifies the expected behavior that the
   ! attributes in subfields are actually just references
   ! to the attributes in the main field.     We do this
   ! by changing an attribute value after creation and checking
   ! the new value on the subfields.
   @test
   subroutine test_subField_attribute_reference(this)
      class(SubFieldTest), intent(inout) :: this

      integer :: status
      type(ESMF_Field), allocatable :: subfields(:)
      integer :: i

      integer(kind=ESMF_KIND_I4) :: i_value
      real(kind=ESMF_KIND_R4) :: x_value
      real(kind=ESMF_KIND_R8) :: y_value
      logical :: flag
      
      subfields = make_subfields(this%field, this%num_subgrids, _RC)

      do i = 1, size(subfields)

         select case (this%atts)
         case ('none')
         case ('A')
            call ESMF_AttributeSet(this%field, name='A', value=7_ESMF_KIND_I4, _RC)
            call ESMF_AttributeGet(subfields(i), name='A', value=i_value, _RC)
            @assert_that(i_value, is(7))

         case ('B')
            call ESMF_AttributeSet(this%field, name='B1', value=7_ESMF_KIND_I4, _RC)
            call ESMF_AttributeGet(subfields(i), name='B1', value=i_value, _RC)
            @assert_that(i_value, is(7))

            call ESMF_AttributeSet(this%field, name='B2', value=7._ESMF_KIND_R4, _RC)
            call ESMF_AttributeGet(subfields(i), name='B2', value=x_value, _RC)
            @assert_that(x_value, is(7._ESMF_KIND_R4))

         case ('C')
            call ESMF_AttributeSet(this%field, name='C1', value=7._ESMF_KIND_R8, _RC)
            call ESMF_AttributeGet(subfields(i), name='C1', value=y_value, _RC)
            @assert_that(y_value, is(7._ESMF_KIND_R8))

            call ESMF_AttributeSet(this%field, name='C2', value=7_ESMF_KIND_I4, _RC)
            call ESMF_AttributeGet(subfields(i), name='C2', value=i_value, _RC)
            @assert_that(i_value, is(7))

            call ESMF_AttributeSet(this%field, name='C3', value=.false., _RC)
            call ESMF_AttributeGet(subfields(i), name='C3', value=flag, _RC)
            @assert_that(flag, is(false()))

         case default
            ! should not reach here
            @assert_that(1, is(0))
         end select
      end do

   end subroutine test_subField_attribute_reference

   @test
   subroutine test_grid(this)
      class(SubFieldTest), intent(inout) :: this

      type(ESMF_Field), allocatable :: subfields(:)
      integer :: status, i
      type(ESMF_Grid) :: grid
      type(ESMF_GridMatch_Flag) :: match_flag
      logical :: match

      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      
      do i = 1, this%num_subgrids
         call ESMF_FieldGet(subfields(i), grid=grid, _RC)
         match_flag = ESMF_GridMatch(grid, this%subgrids(i), _RC)
         match = any(match_flag%gridmatch == [ESMF_GRIDMATCH_EXACT%gridmatch,ESMF_GRIDMATCH_ALIAS%gridmatch])
         @assertTrue(match, message='incorrect grid in subfield')
      end do

   end subroutine test_grid

   ! verify that data of subfields is of the expected typekind
   @test
   subroutine test_typekind(this)
     class(SubFieldTest), intent(inout) :: this
     integer :: status, i
     type(ESMF_Field), allocatable :: subfields(:)
     type(ESMF_TYPEKIND_FLAG) :: typekind

      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      do i = 1, this%num_subgrids
         call ESMF_FieldGet(subfields(i), typekind=typekind, _RC)
         @assertTrue(this%typekind == typekind)
      end do

   end subroutine test_typekind
   
   ! verify that data of subfields is of the expected rank
   @test
   subroutine test_rank(this)
     class(SubFieldTest), intent(inout) :: this
     integer :: status, i
     type(ESMF_Field), allocatable :: subfields(:)
     integer :: rank

      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      do i = 1, this%num_subgrids
         call ESMF_FieldGet(subfields(i), rank=rank, _RC)
         @assert_that(rank, is(this%rank))
      end do

   end subroutine test_rank

   
   @test
   subroutine test_field_data(this)
     class(SubFieldTest), intent(inout) :: this
     integer :: status, i
     type(ESMF_Field), allocatable :: subfields(:)
     real(kind=ESMF_KIND_R4), pointer :: ptr_2d_r4(:,:), sub_ptr_2d_r4(:,:)
     real(kind=ESMF_KIND_R8), pointer :: ptr_2d_r8(:,:), sub_ptr_2d_r8(:,:)
     real(kind=ESMF_KIND_R4), pointer :: ptr_3d_r4(:,:,:), sub_ptr_3d_r4(:,:,:)
     real(kind=ESMF_KIND_R8), pointer :: ptr_3d_r8(:,:,:), sub_ptr_3d_r8(:,:,:)
     integer(kind=ESMF_KIND_I4), pointer :: ptr_2d_i4(:,:), sub_ptr_2d_i4(:,:)
     integer(kind=ESMF_KIND_I4), pointer :: ptr_3d_i4(:,:,:), sub_ptr_3d_i4(:,:,:)
     integer(kind=ESMF_KIND_I8), pointer :: ptr_2d_i8(:,:), sub_ptr_2d_i8(:,:)
     integer(kind=ESMF_KIND_I8), pointer :: ptr_3d_i8(:,:,:), sub_ptr_3d_i8(:,:,:)
     
      ! As with make_subgrids() we first implement a lower level interface
      ! that assumes the subgrids are already available.
      ! the higher level overload will construct the actual subgrids and then
      ! call this lower level procedure.
   
      subfields = make_subfields(this%field, this%num_subgrids, _RC)
      
      do i = 1, this%num_subgrids
         call check(subfields(i), this%bounds(i), _RC)
      end do

   contains

      subroutine check(subfield, bounds, rc)
         type(ESMF_Field), intent(in) :: subfield
         type(Interval), intent(in) :: bounds
         integer, optional, intent(out) :: rc

         select case (this%tk_str)
         case ('R4')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_r4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_r4, _RC)
               @assertEqual(ptr_2d_r4(:,bounds%min:bounds%max), sub_ptr_2d_r4)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_r4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_r4, _RC)
               @assertEqual(ptr_3d_r4(:,bounds%min:bounds%max,:), sub_ptr_3d_r4)
            end select
            
         case ('R8')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_r8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_r8, _RC)
               @assertEqual(ptr_2d_r8(:,bounds%min:bounds%max), sub_ptr_2d_r8)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_r8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_r8, _RC)
               @assertEqual(ptr_3d_r8(:,bounds%min:bounds%max,:), sub_ptr_3d_r8)
            end select

         case ('I4')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_i4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_i4, _RC)
               @assertEqual(ptr_2d_i4(:,bounds%min:bounds%max), sub_ptr_2d_i4)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_i4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_i4, _RC)
               @assertEqual(ptr_3d_i4(:,bounds%min:bounds%max,:), sub_ptr_3d_i4)
            end select

         case ('I8')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_i8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_i8, _RC)
               @assertEqual(ptr_2d_i8(:,bounds%min:bounds%max), sub_ptr_2d_i8)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_i8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_i8, _RC)
               @assertEqual(ptr_3d_i8(:,bounds%min:bounds%max,:), sub_ptr_3d_i8)
            end select

         end select
      end subroutine check

   end subroutine test_field_data


   ! Test that the subfield data is actual pointer into slice of
   ! primary field.   We verify by modifying the primary field,
   ! and check that the subfield data is similarly modfiied.
   @test
   subroutine test_data_alias(this)
     class(SubFieldTest), intent(inout) :: this
     integer :: status, i
     type(ESMF_Field), allocatable :: subfields(:)
     real(kind=ESMF_KIND_R4), pointer :: ptr_2d_r4(:,:), sub_ptr_2d_r4(:,:)
     real(kind=ESMF_KIND_R8), pointer :: ptr_2d_r8(:,:), sub_ptr_2d_r8(:,:)
     real(kind=ESMF_KIND_R4), pointer :: ptr_3d_r4(:,:,:), sub_ptr_3d_r4(:,:,:)
     real(kind=ESMF_KIND_R8), pointer :: ptr_3d_r8(:,:,:), sub_ptr_3d_r8(:,:,:)
     integer(kind=ESMF_KIND_I4), pointer :: ptr_2d_i4(:,:), sub_ptr_2d_i4(:,:)
     integer(kind=ESMF_KIND_I4), pointer :: ptr_3d_i4(:,:,:), sub_ptr_3d_i4(:,:,:)
     integer(kind=ESMF_KIND_I8), pointer :: ptr_2d_i8(:,:), sub_ptr_2d_i8(:,:)
     integer(kind=ESMF_KIND_I8), pointer :: ptr_3d_i8(:,:,:), sub_ptr_3d_i8(:,:,:)
     
     subfields = make_subfields(this%field, this%num_subgrids, _RC)

      do i = 1, this%num_subgrids
         call check(subfields(i), this%bounds(i), _RC)
      end do

   contains

      subroutine check(subfield, bounds, rc)
         type(ESMF_Field), intent(in) :: subfield
         type(Interval), intent(in) :: bounds
         integer, optional, intent(out) :: rc

         select case (this%tk_str)
         case ('R4')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_r4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_r4, _RC)
               ptr_2d_r4 = -1 ! modify
               @assertEqual(ptr_2d_r4(:,bounds%min:bounds%max), sub_ptr_2d_r4)
               
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_r4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_r4, _RC)
               ptr_3d_r4 = -1 ! modify
               @assertEqual(ptr_3d_r4(:,bounds%min:bounds%max,:), sub_ptr_3d_r4)
            end select
            
         case ('R8')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_r8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_r8, _RC)
               ptr_2d_r8 = -1 ! modify
               @assertEqual(ptr_2d_r8(:,bounds%min:bounds%max), sub_ptr_2d_r8)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_r8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_r8, _RC)
               ptr_3d_r8 = -1 ! modify
               @assertEqual(ptr_3d_r8(:,bounds%min:bounds%max,:), sub_ptr_3d_r8)
            end select

         case ('I4')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_i4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_i4, _RC)
               ptr_2d_i4 = -1 ! modify
               @assertEqual(ptr_2d_i4(:,bounds%min:bounds%max), sub_ptr_2d_i4)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_i4, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_i4, _RC)
               ptr_3d_i4 = -1 ! modify
               @assertEqual(ptr_3d_i4(:,bounds%min:bounds%max,:), sub_ptr_3d_i4)
            end select

         case ('I8')

            select case (this%rank)
            case (2)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_2d_i8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_2d_i8, _RC)
               ptr_2d_i8 = -1 ! modify
               @assertEqual(ptr_2d_i8(:,bounds%min:bounds%max), sub_ptr_2d_i8)
            case (3)
               call ESMF_FieldGet(this%field, localDe=0, farrayPtr=ptr_3d_i8, _RC)
               call ESMF_FieldGet(subfield, localDe=0, farrayPtr=sub_ptr_3d_i8, _RC)
               ptr_3d_i8 = -1 ! modify
               @assertEqual(ptr_3d_i8(:,bounds%min:bounds%max,:), sub_ptr_3d_i8)
            end select

         end select
      end subroutine check

   end subroutine test_data_alias



   function toString(this) result(string)
      character(len=:), allocatable :: string
      class (FieldSpec), intent(in) :: this
      character(len=2) :: buf

      string = '{name:'//this%field_name
      string = string //',ATTR:'//this%atts

      write(buf,'(i2.0)') this%im
      string = string // ',IM:'//buf

      string = string // ',TK:'//this%tk_str

      write(buf,'(i2.0)') this%rank
      string = string // ',rank:'//buf

      write(buf,'(i2.0)') this%num_subgrids
      string = string // ',n_grids:'//buf

      write(buf,'(i2.0)') this%nx
      string = string // ',nx:'//buf

      write(buf,'(i2.0)') this%ny
      string = string // ',nx:'//buf

      string = string // '}'

   end function toString

end module test_SubField
